# Java 数据类型与变量笔记


## 1. 变量基础
+ 变量是程序的基本组成单位
+ 变量的三个组成要素：**类型、变量名、值**

## 2. 数据类型分类
Java 数据类型分为两大类：

### 2.1 基本数据类型
包括数值型、字符型、布尔型，具体如下：

| 类型分类 | 具体类型 | 占用存储空间 | 范围/说明 |
| --- | --- | --- | --- |
| 整数类型 | byte（字节型） | 1字节 | -128 ~ 127 |
|  | short（短整型） | 2字节 | -(2¹⁵) ~ 2¹⁵-1 → -32768 ~ 32767 |
|  | int（整型） | 4字节 | -2³¹ ~ 2³¹-1 → -2147483648 ~ 2147483647 |
|  | long（长整型） | 8字节 | -2⁶³ ~ 2⁶³-1 |
| 浮点类型（小数） | float（单精度） | 4字节 | 3.403E38 ~ 3.403E38（有效位数约6-7位） |
|  | double（双精度） | 8字节 | 1.798E308 ~ 1.798E308（有效位数约15-16位） |
| 字符类型 | char | 2字节 | 存放单个字符，对应 Unicode 编码 |
| 布尔类型 | boolean | 1字节 | 仅取值 true（真）、false（假），无 null 值 |


### 2.2 引用数据类型
+ 类（class）
+ 接口（interface）
+ 数组（[]）

## 3. 各数据类型使用细节
### 3.1 整数类型使用细节
1. Java 各整数类型有固定的范围和字段长度，**不受操作系统影响**，保证程序可移植性
2. Java 的整型常量默认是 `int` 型
3. 声明 `long` 型常量时，须加后缀 `l` 或 `L`（推荐大写 L，避免与数字 1 混淆）
4. 程序中变量通常声明为 `int` 型，除非不足以表示大数，才使用 `long` 型
5. 计算机存储单位：1 byte = 8 bit（bit 是计算机最小存储单位）

### 3.2 浮点类型使用细节（FloatDetail.java）
1. 与整数类型类似，Java 浮点类型有固定的范围和字段长度，**不受操作系统影响**
2. Java 的浮点型常量默认是 `double` 型，声明 `float` 型常量须加后缀 `f` 或 `F`
3. 浮点型常量的两种表示形式：
    - 十进制数形式：如 5.12、.512（必须包含小数点）、512.0f
    - 科学计数法形式：如 5.12e2（=512.0）、5.12E-2（=0.0512）
4. 通常优先使用 `double` 型，因为它比 `float` 型更精确
    - 示例：

```java
double num9 = 2.1234567851; // 精度更高
float num10 = 2.1234567851F; // 精度损失
```

5. 浮点数使用陷阱：**不能用 **`==`** 对运算结果是小数的进行相等判断**
    - 示例：2.7 和 8.1/3 比较，需在一定精度范围内判断，而非直接用 `==`

### 3.3 字符类型（char）使用细节
1. 字符常量是用 **单引号** 括起来的单个字符
    - 示例：`char c1='a'; char c2='中'; char c3='9';`
2. 支持转义字符 `\`，将其后的字符转为特殊字符型常量
    - 示例：`char c3='\n';`（`\n` 表示换行符）
3. Java 中 `char` 的本质是一个整数，输出时显示其对应的 Unicode 码字符
    - Unicode 编码查询工具：[http://tool.chinaz.com/Tools/Unicode.aspx](http://tool.chinaz.com/Tools/Unicode.aspx)
4. 可直接给 `char` 赋一个整数，输出时会转换为对应的 Unicode 字符
    - 示例：`char c4=97;`（输出结果为 'a'，因为 97 是 'a' 的 Unicode 码）
5. `char` 类型可以进行运算，相当于一个整数（基于 Unicode 码）
    - 示例：

```java
int n1='a'+'b'; // 'a'=97，'b'=98，n1=195
char char1='a'+2; // 结果为 'c'（97+2=99，对应 'c'）
char c3='韩'; // 支持中文，因为 Unicode 包含中文字符
```

### 3.4 字符类型本质探讨
1. 字符和值的对应关系由 **字符编码表** 决定（固定规则）
2. 常用编码表：ASCII 表（基础字符，如英文字母、数字）、Unicode 表（包含全球字符，兼容 ASCII）

### 3.5 布尔类型（boolean）使用细节
1. 布尔类型数据仅允许取值 `true` 和 `false`，无 `null` 值
2. 占用 1 个字节
3. 适用于逻辑运算，常用于程序流程控制：
    - `if` 条件控制语句
    - `do-while` 循环控制语句
    - `while` 循环控制语句
    - `for` 循环控制语句
4. 示例：

```java
boolean pass=true;
if (pass){
    System.out.println("通过考试");
}else {
    System.out.println("没有通过考试~");
}
```

## 4. 基本数据类型转换
当 Java 程序进行赋值或运算时，不同类型的数据会发生转换，核心原则是 **精度小的类型自动转换为精度大的类型**。

### 4.1 自动转换规则（默认转换）
自动转换方向（容量从小到大）：

+ `byte → short → int → long → float → double`
+ `char → int → long → float → double`

### 4.2 类型转换详细规则（补充笔记）
✅ 1. 混合类型运算：先统一成“容量最大”的类型再算  
👉 规则：  
只要表达式里出现多种类型，Java 会先把所有操作数提升成容量最大的那种类型，再进行计算。

📌 容量大小规律：  
`byte → short → int → long → float → double`

🔹 例子：

```java
int a = 10;
double b = 3.5;
double c = a + b;   // a 自动转成 double 再计算
```

👉 过程：

+ a 是 int 类型
+ b 是 double 类型
+ int 自动提升为 double
+ 运算结果为 double 类型

❌ 错误写法：

```java
int c = a + b;   // 编译错误：double 不能自动赋值给 int
```

✅ 2. 大类型 → 小类型赋值会报错，小 → 大会自动转  
👉 规则：

+ 小容量 → 大容量：可以自动转换（隐式转换）
+ 大容量 → 小容量：必须强制类型转换（显式转换）

🔹 正确（自动转换）：

```java
int a = 10;
double b = a;   // int → double 自动转换
```

🔹 错误（直接赋值）：

```java
double d = 9.8;
int i = d;      // ❌ 编译错误：大容量不能直接赋值给小容量
```

🔹 正确（强制转换）：

```java
double d = 9.8;
int i = (int) d;   // i = 9（小数部分被直接砍掉，精度损失）
```

⚠️ 强转风险：强制转换可能导致精度丢失或数据溢出，需谨慎使用。

✅ 3. byte / short 和 char 之间不会自动转换  
👉 规则：

+ `byte`、`short` 是有符号整数
+ `char` 是无符号字符（范围 0~65535）
+ 三者之间不能自动相互转换

🔹 错误（自动转换）：

```java
byte b = 10;
char c = b;   // ❌ 编译错误：byte 不能自动转 char
```

🔹 正确（强制转换）：

```java
byte b = 10;
char c = (char) b; // 显式强制转换
```

✅ 4. byte、short、char 运算时先统一成 int  
👉 规则：  
只要 `byte`、`short`、`char` 参与运算（+、-、*、/），会先自动转换为 `int` 类型再计算。

🔹 例子（错误）：

```java
byte a = 1;
byte b = 2;
byte c = a + b;   // ❌ 编译错误
```

👉 原因：

+ a、b 先自动转换为 int 类型
+ a + b 的结果是 int 类型
+ int 类型不能自动赋值给 byte 类型

🔹 正确写法（强制转换）：

```java
byte a = 1;
byte b = 2;
byte c = (byte)(a + b); // 显式强制转换结果为 byte
```

再看示例：

```java
char c1 = 'A';   // 'A' 的 Unicode 码是 65
char c2 = 1;
int c3 = c1 + c2;   // 65 + 1 = 66，结果为 int 类型
```

✅ 5. boolean 不参与任何类型转换  
👉 规则：  
`boolean` 类型仅表示逻辑真/假，不能和任何数字类型（byte、short、int 等）相互转换。

🔹 错误（转换尝试）：

```java
boolean b = true;
int i = b;      // ❌ 编译错误：boolean 不能转 int
```

🔹 正确用法（逻辑判断）：

```java
boolean b = true;
if (b) {
    System.out.println("ok");
}
```

✅ 6. 自动提升原则：结果类型 = 操作数中最大的类型  
👉 规则：  
表达式最终结果的类型，等于所有操作数中容量最大的那个类型。

🔹 例子1：

```java
int a = 10;
float b = 2.5f;
var c = a + b;   // c 是 float 类型（int < float）
```

🔹 例子2：

```java
int a = 10;
long b = 20L;
var c = a + b;   // c 是 long 类型（int < long）
```

🔹 例子3：

```java
int a = 10;
double b = 1.2;
var c = a * b;   // c 是 double 类型（int < double）
```

### 4.3 类型转换其他细节
1. 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的类型，再进行运算
2. `byte`、`short`、`char` 三者之间不会相互自动转换
3. `byte`、`short`、`char` 三者可以计算，计算时首先转换为 `int` 类型
4. `boolean` 类型不参与任何类型转换



### 基本数据类型与 String 类型的转换
5.1 基本类型转 String 类型  
语法：将基本类型的值加 "" 即可  
示例代码：  
java  
运行  
public class StringToBasic {  
 // 编写一个 main 方法  
 public static void main(String[] args) {  
 // 基本数据类型 -> String  
 int n1 = 100;  
 float f1 = 1.1f;  
 double d1 = 3.14;  
 boolean b1 = true;  
   
 String s1 = n1 + "";  
 String s2 = f1 + "";  
 String s3 = d1 + "";  
 String s4 = b1 + "";  
   
 System.out.println(s1 + "" + s2 + "" + s3 + "" + s4);  
 }

}  
5.2 String 类型转基本数据类型  
语法：通过基本类型的包装类调用 parseXX 方法即可  
示例代码：  
java  
运行  
public class StringToBasic {  
    public static void main(String[] args) {  
        // String -> 对应的基本数据类型  
        String s5 = "123";

```plain
    // 使用基本数据类型对应的包装类的相应方法，得到基本数据类型
    int num1 = Integer.parseInt(s5);
    double num2 = Double.parseDouble(s5);
    float num3 = Float.parseFloat(s5);
    long num4 = Long.parseLong(s5);
    byte num5 = Byte.parseByte(s5);
    boolean b = Boolean.parseBoolean("true");
    short num6 = Short.parseShort(s5);
}
```

}  
说明：详细解读会在 OOP 讲解对象和方法时展开  
5.3 转换注意事项  
案例演示参考：StringToBasicDetail.java  
转换时需确保 String 内容与目标基本类型匹配，否则会抛出转换异常（如将 "abc" 转为 int 会报错）

