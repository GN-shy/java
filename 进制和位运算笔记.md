## 一、进制介绍
对于整数，有四种表示方式：

1. 二进制：0、1，满2进1，以 `0b` 或 `0B` 开头。
2. 十进制：0-9，满10进1。
3. 八进制：0-7，满8进1，以数字 `0` 开头表示。
4. 十六进制：0-9 及 A(10)-F(15)，满16进1，以 `0x` 或 `0X` 开头表示（此处的A-F不区分大小写）。

## 二、四种进制互相转换的规则和方法
### （一）核心原则
进制转换的本质是“位权转换”，任意进制的数值都可表示为：`dₙ×kⁿ + dₙ₋₁×kⁿ⁻¹ + ... + d₁×k¹ + d₀×k⁰`（其中 `k` 为进制基数，`dᵢ` 为对应位上的数字）。

### （二）具体转换规则+示例
#### 1. 二进制 ↔ 十进制
##### （1）二进制转十进制：按位加权求和
+ 规则：从右至左，每一位数字乘以 `2ⁱ`（`i` 为从0开始的位索引），所有结果相加。
+ 示例：将二进制 `0b1011` 转十进制  
计算过程：`1×2³ + 0×2² + 1×2¹ + 1×2⁰ = 8 + 0 + 2 + 1 = 11`

##### （2）十进制转二进制：除2取余，逆序排列
+ 规则：将十进制数反复除以2，记录每次的余数（0或1），直到商为0，最后将余数从后往前排列即为二进制数。
+ 示例：将十进制 `14` 转二进制  
计算过程：  
14 ÷ 2 = 7 余 0  
7 ÷ 2 = 3 余 1  
3 ÷ 2 = 1 余 1  
1 ÷ 2 = 0 余 1  
逆序排列余数：`0b1110`

#### 2. 二进制 ↔ 八进制
##### （1）二进制转八进制：3位一组，分组求和
+ 规则：从右至左，将二进制数每3位分为一组（不足3位的左边补0），每组按二进制转十进制的方法计算结果，组合即为八进制数。
+ 示例：将二进制 `0b110101` 转八进制  
分组：`011` 和 `0101` → 补0后 `011`、`0101` 错误，正确分组：从右往左3位一组：`110` 和 `101`（原数6位，刚好两组）  
计算：`110`→6，`101`→5 → 八进制 `065`

##### （2）八进制转二进制：每位拆3位，补0对齐
+ 规则：将八进制的每一位数字，转换为对应的3位二进制数（不足3位左边补0），组合即为二进制数。
+ 示例：将八进制 `073` 转二进制  
拆分：7→`111`，3→`011` → 二进制 `0b111011`

#### 3. 二进制 ↔ 十六进制
##### （1）二进制转十六进制：4位一组，分组求和
+ 规则：从右至左，将二进制数每4位分为一组（不足4位的左边补0），每组按二进制转十进制的方法计算结果（10→A、11→B...15→F），组合即为十六进制数。
+ 示例：将二进制 `0b1011010` 转十六进制  
分组：补0后 `0101` 和 `1010`  
计算：`0101`→5，`1010`→A → 十六进制 `0x5A`

##### （2）十六进制转二进制：每位拆4位，补0对齐
+ 规则：将十六进制的每一位数字，转换为对应的4位二进制数（不足4位左边补0），组合即为二进制数。
+ 示例：将十六进制 `0x3D` 转二进制  
拆分：3→`0011`，D→`1101` → 二进制 `0b00111101`（可简化为 `0b111101`）

#### 4. 十进制 ↔ 八进制/十六进制
##### （1）十进制转八进制：除8取余，逆序排列
+ 示例：十进制 `59` 转八进制  
59 ÷ 8 = 7 余 3  
7 ÷ 8 = 0 余 7  
逆序排列：`073`

##### （2）十进制转十六进制：除16取余，逆序排列（余数10→A...15→F）
+ 示例：十进制 `87` 转十六进制  
87 ÷ 16 = 5 余 7  
5 ÷ 16 = 0 余 5  
逆序排列：`0x57`

##### （3）八进制/十六进制转十进制：按位加权求和（基数分别为8、16）
+ 示例1：八进制 `062` 转十进制 → `6×8¹ + 2×8⁰ = 48 + 2 = 50`
+ 示例2：十六进制 `0x2F` 转十进制 → `2×16¹ + 15×16⁰ = 32 + 15 = 47`

#### 5. 八进制 ↔ 十六进制
+ 规则：以二进制为中间桥梁，先转二进制，再转目标进制。
+ 示例：八进制 `056` 转十六进制  
056 → 二进制 `0b101110` → 4位分组 `0010`、`1110` → 十六进制 `0x2E`

## 三、二进制在运算中的说明
1. 二进制是逢2进位的进位制，0、1是基本算符。
2. 现代的电子计算机技术全部采用的是二进制，因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现。
3. 计算机内部处理的信息，都是采用二进制数来表示的。二进制（Binary）数用0和1两个数字及其组合来表示任何数。
4. 进位规则是“逢2进1”，数字1在不同的位上代表不同的值，按从右至左的次序，这个值以二倍递增。

## 四、原码、反码、补码（重点）
网上对原码、反码、补码的解释过于复杂，精简核心要点：

+ 适用范围：针对有符号数（Java中无无符号数，所有数均为有符号数）
+ 符号位规则：二进制的最高位是符号位，`0` 表示正数，`1` 表示负数（口诀：0→正，1→负）
+ 正数特性：原码、反码、补码都相同（三码合一）
+ 负数特性：
    1. 负数的反码 = 它的原码符号位不变，其它位取反（0→1，1→0）
    2. 负数的补码 = 它的反码 + 1
    3. 负数的反码 = 负数的补码 - 1
+ 特殊值：0的反码、补码都是0
+ 运算规则：计算机运算时，均以补码的方式进行。

## 五、位运算符
Java中包含7个位运算符，分别是：按位与 `&`、按位或 `|`、按位异或 `^`、按位取反 `~`、算术左移 `<<`、逻辑右移 `>>>`。

### （一）基本位运算符（按位运算，针对二进制位）
#### 1. 按位与 `&`
+ 运算规则：两位全为1，结果为1，否则为0。
+ 示例：计算 `2 & 3`  
2 的二进制：`0b10`  
3 的二进制：`0b11`  
按位运算：  
  1 0  
& 1 1

---

  1 0 → 结果为 `2`

#### 2. 按位或 `|`（详细讲解）
+ 定义：针对两个二进制数的每一位，只要其中有一位是1，该位的运算结果就是1；只有当两位都为0时，结果才为0。
+ 核心逻辑：“有1则1，全0才0”。
+ 示例1：计算 `2 | 3`  
步骤1：将十进制数转为二进制（Java中默认以补码表示，正数补码=原码）  
2 → 二进制 `0b00000010`（简化为 `0b10`）  
3 → 二进制 `0b00000011`（简化为 `0b11`）  
步骤2：按位逐位运算  
  0 0 0 0 0 0 1 0  
| 0 0 0 0 0 0 1 1

---

  0 0 0 0 0 0 1 1 → 对应的十进制数为 `3`

+ 示例2：计算 `5 | 7`  
5 → `0b101`，7 → `0b111`  
运算结果：`0b111` → 十进制 `7`

#### 3. 按位异或 `^`（详细讲解）
+ 定义：针对两个二进制数的每一位，当两位数字不同（一个为0，一个为1）时，结果为1；当两位数字相同（都为0或都为1）时，结果为0。
+ 核心逻辑：“异则1，同则0”。
+ 特性：一个数与自身异或结果为0（`a ^ a = 0`）；一个数与0异或结果为自身（`a ^ 0 = a`）。
+ 示例1：计算 `2 ^ 3`  
2 → `0b00000010`，3 → `0b00000011`  
按位运算：  
  0 0 0 0 0 0 1 0  
^ 0 0 0 0 0 0 1 1

---

  0 0 0 0 0 0 0 1 → 对应的十进制数为 `1`

+ 示例2：计算 `6 ^ 4`  
6 → `0b110`，4 → `0b100`  
运算结果：`0b010` → 十进制 `2`

#### 4. 按位取反 `~`（详细讲解）
+ 定义：针对一个二进制数的每一位，进行“0→1，1→0”的反转操作（包括符号位）。
+ 核心逻辑：“逐位反转，符号位也反转”。
+ 注意：Java中数字为有符号数，按位取反后结果需结合补码规则计算最终十进制值（计算步骤：原码→取反→补码→转十进制）。
+ 示例1：计算 `~2`  
步骤1：2是正数，原码=补码 → `0b00000000 00000000 00000000 00000010`（32位int类型）  
步骤2：按位取反 → `0b11111111 11111111 11111111 11111101`（这是补码形式）  
步骤3：补码转原码（负数补码转原码：补码-1 → 反码 → 符号位不变，其余位取反）  
  补码-1：`0b11111111 11111111 11111111 11111100`（反码）  
  反码转原码：符号位不变，其余位取反 → `0b10000000 00000000 00000000 00000011`  
步骤4：原码转十进制 → `-3`  
最终结果：`~2 = -3`
+ 示例2：计算 `~-2`  
步骤1：-2是负数，先求原码 → `0b10000000 00000000 00000000 00000010`  
步骤2：原码转反码 → 符号位不变，其余位取反 → `0b11111111 11111111 11111111 11111101`  
步骤3：反码转补码 → 反码+1 → `0b11111111 11111111 11111111 11111110`（计算机中存储的补码）  
步骤4：按位取反 → `0b00000000 00000000 00000000 00000001`（补码，正数补码=原码）  
步骤5：转十进制 → `1`  
最终结果：`~-2 = 1`

### （二）移位运算符（针对二进制位的位移操作）
#### 1. 算术左移 `<<`
+ 运算规则：符号位不变，低位补0。
+ 核心本质：左移n位，相当于该数乘以 `2ⁿ`（正数、负数均适用，不改变符号）。
+ 示例：`3 << 2`  
3 的二进制：`0b11`  
左移2位：符号位不变，低位补0 → `0b1100` → 十进制 `12`（3×2²=12）

#### 2. 逻辑右移（无符号右移） `>>>`
+ 运算规则：低位溢出，高位补0（不考虑符号位，所有位统一右移，高位补0）。
+ 注意：仅适用于整数类型，对负数右移后会变成正数（因为高位补0）。
+ 示例1：`8 >>> 2`  
8 的二进制：`0b1000`  
右移2位：低位2位溢出，高位补0 → `0b10` → 十进制 `2`（8÷2²=2）
+ 示例2：`-8 >>> 2`（32位int类型）  
-8 的补码：`0b11111111 11111111 11111111 11111000`  
右移2位：低位2位溢出，高位补0 → `0b00111111 11111111 11111111 11111110`  
转十进制：`1073741822`

## 六、特别说明
1. 没有 `<<<` 符号（无符号左移）。
2. Java中所有位运算均基于补码进行，尤其是负数的运算需注意补码、反码、原码的转换。

## 
